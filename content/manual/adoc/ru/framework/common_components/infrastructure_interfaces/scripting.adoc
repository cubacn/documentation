:sourcesdir: ../../../../../source

[[scripting]]
===== Scripting

++++
<div class="manual-live-demo-container">
    <a href="http://files.cuba-platform.com/javadoc/cuba/7.2/com/haulmont/cuba/core/global/Scripting.html" class="api-docs-btn" target="_blank">API DOCS</a>
</div>
++++

Интерфейс `Scripting` позволяет динамически (т.е. во время работы приложения) компилировать и загружать классы Java и Groovy, а также выполнять скрипты и выражения на Groovy.

Методы `Scripting`:

* `evaluateGroovy()` - выполняет выражение на Groovy и возвращает его результат. 
+
Свойство приложения <<cuba.groovyEvaluatorImport,cuba.groovyEvaluatorImport>> позволяет определить общий набор импортируемых классов, подставляемых в каждое выполняемое выражение. По умолчанию все стандартные блоки приложения импортируют класс <<persistenceHelper,PersistenceHelper>>.
+
Скомпилированные выражения кэшируются, что значительно ускоряет повторное выполнение.
+
Пример:
+
[source, java]
----
include::{sourcesdir}/common/scripting_1.java[]
----

[[scripting.runGroovyScript]]
* `runGroovyScript()` - выполняет скрипт Groovy и возвращает его результат.
+
Скрипт должен быть расположен либо в <<conf_dir,конфигурационном каталоге>> приложения, либо в classpath (текущая реализация `Scripting` поддерживает ресурсы classpath только внутри JAR-файлов). Скрипт в конфигурационном каталоге замещает одноименный скрипт в classpath.
+
Путь к скрипту указывается с разделителями `/`, в начале пути символ `/` не требуется.
+
Пример:
+
[source, java]
----
include::{sourcesdir}/common/scripting_2.java[]
----

* `loadClass()` - загружает Java или Groovy класс, используя следующую последовательность действий:

. Если класс уже загружен, возвращает его.

. Ищет исходный текст Groovy (файл `*.groovy`) в каталоге конфигурации. Если найден, компилирует его, загружает и возвращает класс.

. Ищет исходный текст Java (файл `*.java`) в каталоге конфигурации. Если найден, компилирует его, загружает и возвращает класс.

. Ищет скомпилированный класс в classpath, если найден - загружает и возвращает его.

. Если ничего не найдено, возвращает `null`.
+
Файлы исходных текстов Java и Groovy в каталоге конфигурации можно изменять во время работы приложения. При следующем вызове `loadClass()` соответствующий класс будет перекомпилирован и возвращен новый, однако существуют следующие ограничения:

** нельзя изменять тип исходного текста с Groovy на Java

** если существовал исходный текст Groovy, и был однажды скомпилирован, то удаление файла исходного текста не приведет к загрузке другого класса из classpath - будет по-прежнему возвращаться класс, скомпилированный из удаленного исходника.
+
Пример:
+
[source, java]
----
include::{sourcesdir}/common/scripting_3.java[]
----

* `getClassLoader()` - возвращает `ClassLoader`, способный работать по правилам, описанным выше для метода `loadClass()`.

Кэш скомпилированных классов можно очистить во время выполнения с помощью JMX-бина <<cachingFacadeMBean,CachingFacadeMBean>>.

См. также <<scriptingManagerMBean,ScriptingManagerMBean>>.

