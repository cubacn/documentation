:sourcesdir: ../../../../../source

[[dataManager]]
===== DataManager

++++
<div class="manual-live-demo-container">
    <a href="http://files.cuba-platform.com/javadoc/cuba/7.1/com/haulmont/cuba/core/global/DataManager.html" class="api-docs-btn" target="_blank">API DOCS</a>
</div>
++++

Интерфейс `DataManager` является универсальным средством для загрузки графов сущностей из базы данных, и для сохранения изменений, произведенных в detached экземплярах сущностей. 

[TIP]
====
В разделе <<dm_vs_em>> приведена информация о различиях между DataManager и <<entityManager,EntityManager>>.
====

`DataManager` на самом деле делегирует выполнение реализациям <<data_store,DataStore>>, и поддерживает ссылки между сущностями из разных хранилищ. Большинство деталей реализации, описанных ниже, актуальны только когда производится работа через `RdbmsStore` с сущностями, хранящимися в реляционной БД. Для другого типа хранилища все, кроме сигнатур методов, может отличаться. Для простоты изложения, далее, когда мы говорим просто _DataManager_, мы будем иметь в виду _DataManager через RdbmsStore_.

Методы `DataManager`:

* `load(Class)` - загружает сущности указанного типа. Данный метод является точкой входа в fluent API:
+
[source, java]
----
include::{sourcesdir}/common/dataManager_4.java[]
----

* `loadValues(String query)` - загружает пары ключ-значение по запросу, возвращающему скалярные значения. Данный метод является точкой входа в fluent API:
+
[source, java]
----
include::{sourcesdir}/common/dataManager_5.java[]
----
+
<1> - укажите хранилище, в котором находится сущность. Данный метод можно опустить, если сущность находится в главном хранилище.
<2> - перечислите имена атрибутов результирующей `KeyValueEntity`. Порядок имен должен соответствовать колонкам результирующего набора в запросе.

* `loadValue(String query, Class valueType)` - загружает единственное значение по запросу. Данный метод является точкой входа в fluent API:
+
[source, java]
----
include::{sourcesdir}/common/dataManager_6.java[]
----
+
<1> - укажите хранилище, в котором находится сущность. Данный метод можно опустить, если сущность находится в главном хранилище.

* `load(LoadContext)`, `loadList(LoadContext)` - загружает сущности в соответствии с параметрами переданного объекта `LoadContext`. В `LoadContext` обязательно должен быть передан либо JPQL-запрос, либо идентификатор сущности. Если передано и то и другое, используется запрос, а идентификатор игнорируется. Примеры:
+
[source, java]
----
include::{sourcesdir}/common/dataManager_1.java[]
---- 

* `loadValues(ValueLoadContext)` - загружает список пар ключ-значение. Метод принимает объект `ValueLoadContext`, в котором задается запрос и список ключей. Возвращаемый список содержит экземпляры `KeyValueEntity`. Например:
+
[source, java]
----
include::{sourcesdir}/common/dataManager_3.java[]
----

* `getCount(LoadContext)` - возвращает количество записей для запроса, переданного в метод. Когда возможно, для максимальной производительности, стандартная реализация в классе `RdbmsStore` выполняет запрос `select count()` с условиями исходного запроса.

* `commit(CommitContext)` - сохраняет в базе данных набор сущностей, переданный в объекте `CommitContext`. Отдельно указываются коллекции сущностей, которые нужно сохранить и которые нужно удалить.
+
Метод возвращает набор экземпляров сущностей, возвращенных из метода <<entityManager,EntityManager>>.merge(), то есть по сути свежие экземпляры, только что обновленные в БД. Дальнейшая работа должна производиться именно с этими возвращенными экземплярами, чтобы предотвратить потерю данных или исключения оптимистичной блокировки. Для того, чтобы обеспечить наличие нужных атрибутов у возвращенных сущностей, с помощью мэп `CommitContext.getViews()` можно указать <<views,представление>> для каждого сохраняемого экземпляра. 
+
Примеры сохранения коллекций сущностей:
+
[source, java]
----
include::{sourcesdir}/common/dataManager_2.java[]
---- 

* `reload(Entity, View)` - удобный метод для перезагрузки экземпляра сущности с требуемым <<views,представлением>>. Делегирует выполнение методу `load()`.

* `remove(Entity)` - удаляет экземпляр сущности из базы данных. Делегирует выполнение методу `commit()`.

* `create(Class)` - создает экземпляр данной сущности в памяти. Этот метод просто делегирует в `Metadata.create()`.

* `getReference(Class, Object)` - возвращает экземпляр сущности, который может быть использован в качестве ссылки на объект, существующий в базе данных.
+
--
Например, если вы создаете экземпляр сущности `User`, вам необходимо установить ссылку на `Group`, в которую данный пользователь будет входить. Если вам известен id группы, то вы могли бы загрузить данную группу из БД. Данный метод позволяет получить экземпляр `Group` без ненужного обращения к БД:

[source, java]
----
include::{sourcesdir}/common/dataManager_7.java[]
----

Ссылка может также быть использована для удаления существующего объекта по идентификатору:

[source, java]
----
include::{sourcesdir}/common/dataManager_8.java[]
----
--

[[dm_query]]
Запросы::
+
--
Правила создания запросов аналогичны описанным в разделе <<query,Выполнение JPQL-запросов>>. Отличием является то, что в запросе, выполняемом через `DataManager`, могут быть использованы только именованные параметры, позиционные не поддерживаются.
--

[[dm_transactions]]
Транзакции::
+
--
`DataManager` всегда стартует новую транзакцию и по завершении работы выполняет коммит, таким образом возвращая сущности в <<entity_states,detached состоянии>>. На среднем слое можно использовать <<transactionalDataManager,TransactionalDataManager>>, если необходимо реализовать сложное транзакционное поведение.
--

[[dm_partial_entities]]
Частичные сущности::
+
--
_Частичная сущность_ - это экземпляр сущности, в котором может быть загружена только часть локальных атрибутов. По умолчанию, DataManager загружает частичные сущности в соответствии с указанными <<views,представлениями>>. (на самом деле, `RdbmsStore` просто устанавливает свойство <<view_loadPartialEntities,loadPartialEntities>> у представления в true и передает его дальше в <<entityManager,EntityManager>>).

В некоторых случаях DataManager загружает все локальные атрибуты и представление определяет только загрузку связей:

* Загружаемая сущность <<entity_cache,кэшируется>>.
* Для сущности заданы in-memory "read" <<constraints,ограничения>>.
* Для сущности задан динамический <<entity_attribute_access,контроль доступа к атрибутам>>.
* Атрибут `loadPartialEntities` объекта `LoadContext` установлен в false.
--

include::dataManager/dm_vs_em.adoc[]

include::dataManager/transactionalDataManager.adoc[]

include::dataManager/dm_security.adoc[]

include::dataManager/query_with_distinct.adoc[]

include::dataManager/query_from_selected.adoc[]

