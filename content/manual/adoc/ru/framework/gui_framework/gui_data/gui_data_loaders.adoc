:sourcesdir: ../../../../../source

[[gui_data_loaders]]
===== Загрузчики данных

Загрузчики, или loaders, предназначены для загрузки данных со среднего слоя в <<gui_data_containers,контейнеры данных>>.

Интерфейсы загрузчиков немного отличаются в зависимости от типа контейнера, с которым они работают:

* `InstanceLoader` загружает единственный экземпляр сущности в контейнер `InstanceContainer` по идентификатору сущности или с помощью JPQL-запроса.

* `CollectionLoader` загружает коллекцию сущностей в `CollectionContainer` с помощью JPQL-запроса. Для этого загрузчика можно настроить пагинацию, сортировку и другие дополнительные параметры.

* `KeyValueCollectionLoader` загружает коллекцию экземпляров `KeyValueEntity` в контейнер `KeyValueCollectionContainer`. Кроме параметров, доступных для `CollectionLoader`, вы также можете указать имя <<data_store,хранилища данных>>.

В XML-дескрипторах экрана загрузчики объявляются с помощью элемента `<loader>`, тип загрузчика будет определяться типом контейнера, в который он вложен.

Использование загрузчиков необязательно, так как вы можете загружать данные с помощью `DataManager` или собственного сервиса и самостоятельно добавлять их в контейнеры, однако загрузчики облегчают этот процесс для экранов, описываемых декларативно, особенно в случае компонента <<gui_Filter,Filter>>. Обычно загрузчик коллекций получает запрос JPQL из XML-дескриптора экрана, а параметры запроса - из компонента `Filter`, затем создаёт объект `LoadContext` и вызывает `DataManager` для загрузки сущностей. В итоге, XML-дескриптор выглядит подобным образом:

[source, xml]
----
include::{sourcesdir}/gui/data_loaders/loader_1.xml[]
----

Дополнительные параметры для XML-элемента `loader` можно указать с помощью атрибутов `cacheable`, `softDeletion` и т.д.

В экране редактора сущности XML-элемент `loader` обычно пуст, так как для загрузки единственного экземпляра сущности требуется её идентификатор, который устанавливается программно классом `StandardEditor`:

[source, xml]
----
include::{sourcesdir}/gui/data_loaders/loader_2.xml[]
----

Загрузчики могут делегировать непосредственно загрузку данных отдельной функции, переданной с помощью метода `setLoadDelegate()` либо декларативно с помощью аннотации `@Install` в контроллере экрана, например:

[source, java]
----
include::{sourcesdir}/gui/data_loaders/loader_3.java[]
----

В данном примере метод `customersDlLoadDelegate()` используется загрузчиком `customersDl` для получения списка экземпляров сущности `Customer`. Метод принимает `LoadContext`, который будет создан загрузчиком на основе его параметров: запрос, фильтр (при наличии) и т.д. В этом примере загрузка осуществляется через интерфейс `DataManager`, который функционально повторяет стандартную реализацию загрузчика, однако вы можете использовать собственный сервис или же выполнить пост-обработку загруженных сущностей.

Загрузчики посылают события `PreLoadEvent` и `PostLoadEvent`, которые можно использовать для выполнения некоторой логики до или после загрузки:

[source, java]
----
include::{sourcesdir}/gui/data_loaders/loader_5.java[]
----

Загрузчики также можно создавать и настраивать программно, к примеру:

[source, java]
----
include::{sourcesdir}/gui/data_loaders/loader_4.java[]
----

Если для загрузчика установлен <<gui_DataContext,DataContext>> (как всегда бывает в случае, если загрузчик задан в XML-дескрипторе), все загруженные сущности будут автоматически помещены в data context.

[[gui_data_loader_query_conditions]]
Условия запросов::
+
--
Иногда необходимо изменить запрос загрузчика данных во время выполнения программы для того, чтобы отфильтровать загружаемые данные на уровне БД. Простейший способ фильтрации в зависимости от параметров, вводимых пользователем - это подключить к загрузчику UI-компонент <<gui_Filter,Filter>>.

Вместо использования универсального фильтра, или в дополнение к нему, для запроса в загрузчике можно задать набор условий. Условие представляет собой набор фрагментов запросов с параметрами. Эти фрагменты будут добавлены в результирующий запрос, _только если все параметры, используемые во фрагментах, заданы для запроса_. Условия обрабатываются на уровне <<data_store,хранилищ данных>>, поэтому они могут содержать фрагменты различных языков запросов, поддерживаемых хранилищами. Фреймворк предоставляет возможность описывать условия на языке JPQL.

Рассмотрим создание условий для фильтрации сущности `Customer` по двум ее атрибутам: строковому `name` и булевскому `status`.

Условия запроса для загрузчика могут быть заданы либо декларативно в XML-элементе `<condition>`, либо программно методом `setCondition()`. Ниже приведен пример описания условий в XML:

[source, xml]
----
include::{sourcesdir}/gui/data_loaders/loader_condition_1.xml[]
----
<1> - добавьте namespace для JPQL-условий
<2> - добавьте элемент `condition` внутри `query`
<3> - если необходимо задать более одного условия, добавьте элемент `and` или `or`
<4> - задайте JPQL-условие с опциональным элементом `join` и обязательным `where`

Предположим, что в экране имеется два UI-компонента для ввода параметров условий: текстовое поле `nameFilterField` и флажок `statusFilterField`. Для того, чтобы обновить данные, когда пользователь изменяет значения в этих компонентах, добавим следующие подписки на события в контроллере экрана:

[source, java]
----
include::{sourcesdir}/gui/data_loaders/loader_condition_1.java[]
----
<1> - обратите внимание, что здесь используется <<query_case_insensitive>> обеспечиваемый ORM

Как было упомянуто выше, условие включается в запрос только когда его параметры установлены. Поэтому результирующий запрос, выполняемый БД, будет зависеть от того, что введено в UI-компонентах:

.Значение введено только в nameFilterField
[source]
----
select e from demo_Customer e where e.name like :name
----

.Значение введено только в statusFilterField
[source]
----
select e from demo_Customer e where e.status = :status
----

.Значение введено и в nameFilterField и в statusFilterField
[source]
----
select e from demo_Customer e where (e.name like :name) and (e.status = :status)
----
--
