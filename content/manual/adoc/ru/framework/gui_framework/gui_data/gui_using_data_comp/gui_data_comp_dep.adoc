:sourcesdir: ../../../../../../source

[[gui_data_comp_dep]]
====== Зависимости между компонентами данных

Иногда требуется загружать и отображать данные, которые зависят от других данных в том же экране. К примеру, на скриншоте ниже таблица слева отображает список заказов, а таблица справа - список строк выбранного заказа. Список справа обновляется каждый раз, когда меняется выбранный заказ в таблице слева.

.Зависимые таблицы
image::gui_data/dep_data_comp.png[align="center"]

В нашем примере сущность `Order` содержит атрибут `orderLines`, который является коллекцией с отношением one-to-many. Самый простой способ реализации экрана - загружать список заказов с представлением, содержащим атрибут `orderLines`, и использовать <<gui_property_containers,property container>> для работы со списком зависимых строк. Затем мы связываем левую таблицу с родительским контейнером, а правую - с контейнером свойства.

Однако этот подход может иметь последствия для производительности, ведь мы загружаем все строки для всех заказов из левой таблицы, несмотря на то, что в один момент времени отображаются строки только для одного выбранного заказа. При этом чем длиннее список заказов, тем больше ненужных данных будет загружено, и вероятность того, что пользователь захочет просмотреть все строки, очень мала. Поэтому мы рекомендуем использовать контейнеры свойств и расширенные представления только тогда, когда нужно загрузить единственный экземпляр родительской сущности: например, в экране редактирования одного заказа.

Кроме того, родительская сущность может не иметь прямого атрибута, указывающего на зависимую сущности. В этом случае подход с использованием контейнера свойств совсем не подходит.

Наилучшей практикой организации отношений между данными в экране является использование запросов с параметрами. Зависимый загрузчик содержит запрос с параметром, который связывает данные с родительским контейнером, и когда меняется текущий экземпляр в родительском контейнере, мы передаём его в качестве параметра и вызываем зависимый загрузчик.

Рассмотрим пример экрана, в котором есть две зависимых пары контейнер/загрузчик и привязанные к ним таблицы для отображения данных.

[source, xml]
----
include::{sourcesdir}/gui/data_comp/data_comp_dep_1.xml[]
----

<1> Родительский контейнер и загрузчик.
<2> Дочерний контейнер и загрузчик.
<3> Основная таблица.
<4> Зависимая таблица.

[source, java]
----
include::{sourcesdir}/gui/data_comp/data_comp_dep_1.java[]
----

<1> Класс контроллера экрана не содержит аннотации `@LoadDataBeforeShow`, поэтому загрузчики не будут вызваны автоматически.
<2> Родительский загрузчик вызывается обработчиком `BeforeShowEvent`.
<3> В обработчике родительского контейнера `ItemChangeEvent` передаём параметр в зависимый загрузчик и вызываем его.

[TIP]
====
Невизуальный компонент <<gui_DataLoadCoordinator,DataLoadCoordinator>> позволяет устанавливать связи между компонентами данных декларативно без написания кода на Java.
====