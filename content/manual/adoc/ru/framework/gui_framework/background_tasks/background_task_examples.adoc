:sourcesdir: ../../../../../source

[[background_task_examples]]
===== Примеры использования фоновых задач

[[background_task_example_BackgroundWorkProgressWindow]]
Отображение выполнения и управление фоновой задачей с помощью BackgroundWorkProgressWindow::
+
--
Часто при запуске фоновых задач появляется необходимость отображения простого UI:
[loweralpha]
. показать пользователю, что запрошенное действие находится в процессе выполнения,
. дать пользователю возможность прервать запрошенное долгое действие,
. показать процент выполнения, если его можно определить.

Для реализации этих потребностей платформа предоставляет вспомогательные классы `BackgroundWorkWindow` и `BackgroundWorkProgressWindow`.
Эти классы содержат статические методы, позволяющие связать фоновую задачу с модальным диалогом, отображающим заголовок, описание, индикатор прогресса и возможно кнопку `Отмена`.
Разница между этими двумя классами в том, что `BackgroundWorkProgressWindow` использует определённый индикатор прогресса, и оно должно использоваться только если задача может оценить процент своего выполнения.
Класс `BackgroundWorkWindow` следует использовать для задач, где нельзя оценить прогресс выполнения.

В качестве примера рассмотрим следующую задачу по разработке:

- Некоторый экран содержит таблицу, отображающую список студентов, с включенным множественным выделением.
- По нажатию кнопки система должна послать письма-напоминания выбранным студентам, без блокировки UI и с возможностью прервать действие.

image::gui_bg_tasks/bg-task-emails.png[align="center"]

Пример реализации:
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_sample_emails.java[]
----
<1> - запустить задачу и показать модальное окно с прогрессом
<2> - установить опции диалога: "размер" индикатора прогресса, пользователь может прервать задачу, показывать прогресс в процентах
<3> - прогресс задачи измеряется в `Integer` (число обработанных элементов таблицы), а тип результата - `Void`, потому что эта задача не производит результата
<4> - выбранные элементы таблицы сохраняются в переменную, которая инициализируется в конструкторе задачи. Это необходимо, потому что метод `run()` исполняется в фоновом потоке и не может обращаться к UI компонентам.
<5> - установить таймаут равный 10 минутам
<6> - периодически проверяется `isCancelled()`, чтобы задача сразу завершилась после того, как пользователь нажмет кнопку `Cancel`
<7> - обновить индикатор прогресса после каждого посланного письма
--

[[background_task_example_BackgroundTaskWrapper]]
Периодическое фоновое обновление данных экрана с использованием Timer и BackgroundTaskWrapper::
+
--
`BackgroundTaskWrapper` - это вспомогательный класс, тонкая обертка вокруг `BackgroundWorker`. Он предоставляет простое API для случаев, когда фоновые задачи одного и того же вида запускаются, перезапускаются и отменяются много раз.

В качестве примера использования рассмотрим следующую задачу по разработке:

- Имеется экран мониторинга очередей, в котором нужно отображать и автоматически обновлять какие-то табличные данные.
- Данные загружаются медленно, и поэтому их нужно загружать в фоне.
- Нужно отображать на экране время последнего обновления.
- Данные ограничены простым фильтром (флажок checkbox).

image::gui_bg_tasks/bg-ranks-ok.png[align="center"]

- Если обновить данные по каким-то причинам не получилось, то экран должен оповестить об этом пользователя:

image::gui_bg_tasks/bg-ranks-error.png[align="center"]

Пример реализации:
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_sample_ranks.java[]
----
<1> - создать экземпляр `BackgroundTaskWrapper` через конструктор без параметров; для каждой итерации будет передан новый экземпляр задачи
<2> - немедленно запустить фоновое обновление данных после смены состояния флажка
<3> - каждое срабатывание таймера запускает фоновое обновление данных
<4> - задача не публикует ход прогресса, поэтому тип прогресса `Void`; задача производит результат с типом `List<Rank>`
<5> - состояние флажка сохраняется в переменную, которая инициализируется в конструкторе задачи. Это необходимо, потому что метод `run()` выполняется в фоновом потоке и не может обращаться к UI компонентам.
<6> - вызов пользовательского сервиса для загрузки данных (это долгое действие и исполняется в фоновом потоке)
<7> - применить успешно полученный результат к компонентам экрана
<8> - обновить UI в особом случае, если загрузка данных не выполнилась за время таймаута: показать уведомление в углу экрана
<9> - проинформировать пользователя, показав уведомление, если загрузка данных завершилась исключением
--
