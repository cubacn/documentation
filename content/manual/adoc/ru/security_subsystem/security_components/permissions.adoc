:sourcesdir: ../../../../source

[[permissions]]
==== Разрешения

_Разрешение_ определяет право пользователя на какой-либо объект или функциональность системы: экран, операцию над сущностью и так далее. Разрешение в зависимости от своего значения может как дать пользователю право на объект, так и отобрать его (то есть по сути являться _запрещением_).

[TIP]
====
Если явного разрешения на объект не установлено, пользователь имеет право на этот объект.
====

Разрешения представляются экземплярами сущности `sec$Permission` и содержат следующие атрибуты:

* `type` - тип разрешения: определяет, на какой тип объектов накладывается разрешение.

* `target` - конкретный объект разрешения. Формат представления объекта зависит от типа разрешения.

* `value` - значение разрешения. Диапазон значений зависит от типа разрешения.

Рассмотрим типы разрешений:

* `PermissionType.SCREEN` - разрешение на экран системы.
+
В атрибуте `target` указывается идентификатор экрана, атрибут `value` может иметь значения 0 или 1 (экран запрещен или разрешен соответственно).
+
Права на экраны проверяются при построении главного меню системы и при каждом вызове методов `openWindow()`, `openEditor()`, `openLookup()` интерфейса <<abstractFrame,Frame>>.
+
Для проверки права на экран в прикладном коде используйте метод `isScreenPermitted()` интерфейса <<security,Security>>.

* `++PermissionType.ENTITY_OP++` - разрешение на операцию c сущностью.
+
В атрибуте `target` указывается имя сущности и через символ ":" имя операции: `create`, `read`, `update`, `delete`. Например: `library$Book:delete`. Атрибут `value` может иметь значения 0 или 1 (операция запрещена или разрешена соответственно).
+
Права на операции с сущностью проверяются при работе с данными через <<dataManager,DataManager>>, а также в связанных с данными <<gui_components,визуальных компонентах>> и <<standard_actions,стандартных действиях>> со списками сущностей. В результате права на операции оказывают влияние на поведение клиентских блоков и {rest_man_url}[REST API]. При работе с данными непосредственно на Middleware через <<entityManager,EntityManager>> права не проверяются.
+
Для проверки права на операцию c сущностью в прикладном коде используйте метод `isEntityOpPermitted()` интерфейса <<security,Security>>.

* `++PermissionType.ENTITY_ATTR++` - разрешение на атрибут сущности.
+
В атрибуте `target` указывается имя сущности и через символ ":" имя атрибута, например: `library$Book:name`. Атрибут `value` может иметь значения 0, 1 или 2 (атрибут скрыт, только для чтения, или полностью разрешен соответственно).
+
Права на атрибуты сущностей проверяются только в связанных с данными <<gui_components,визуальных компонентах>> и {rest_man_url}[REST API].
+
Для проверки права на атрибут сущности в прикладном коде используйте метод `isEntityAttrPermitted()` интерфейса <<security,Security>>.

* `PermissionType.SPECIFIC` - разрешение на произвольную именованную функциональность. Такие разрешения удобно использовать вместо ролей, когда нужно бинарное запрещение/разрешение определённой функциональности конкретного проекта, так как роли - это агрегаторы разрешений.
+
В атрибуте `target` указывается код функциональности, атрибут `value` может иметь значения 0 или 1 (запрещено или разрешено соответственно).
+
Набор специфических разрешений для данного проекта задается в конфигурационном файле <<permissions.xml,permissions.xml>>.
+
Пример использования:
+
[source, java]
----
@Inject
private Security security;

private void calculateBalance() {
    if (!security.isSpecificPermitted("myapp.calculateBalance"))
        return;
    ...
}
----

* `PermissionType.UI` - разрешение на произвольный компонент экрана.
+
В атрибуте `target` указывается идентификатор экрана и через символ ":" путь к компоненту. Описание формата пути см. в следующем разделе.

[TIP]
====
Для проверки разрешений вместо непосредственного использования методов класса `UserSession` рекомендуется использовать аналогичные методы интерфейса <<security,Security>>, принимающие во внимание возможное <<entity_extension,расширение>> сущностей.
====

